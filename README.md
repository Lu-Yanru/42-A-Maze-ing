*This project has been created as part of the 42 curriculum by lvasconc and yanlu.*

# A-Maze-ing
## Description
This project implements a maze generator in Python that takes a configuration file, generates a maze based on the given configuration, writes the maze, entry and exit points and the shortest solution to an outputfile, and also visualize the results.

All generated mazes contain a "42" pattern at the center consisting of fully closed cells, unless the maze is too small for the pattern (smaller than 7 x 5). In this case, a maze without the "42" pattern will be generated.

### Maze generation algorithms
The following algorithms are implemented to generate the maze:

#### Depth-First Search (DFS) algorithm

#### Prim's algorithm
Prim's algorithms tries to connect unvisited cells to visited cells from all directions.
It connects until all cells are connected.

- Step 1: Start from the given entry cell and mark it as visited.
- Step 2: Get a list of unvisited neighbors of the current cell, called frontier.
- Step 3: Randomly choose a new cell from the frontier.
- Step 4: Randomly choose a already visited neighbor of the new cell.
- Step 5: Remove the wall between the new cell and its neighbor (connect the new cell to the visited path).
- Step 6: Marke the new cell as visited and remove it from the frontier.
- Step 7: Add the unvisited neighbors of the new cell to the frontier (the new cell creates new frontier).
- Step 8: Repeat step 3 - 7 until the frontier is empty (all cells are visited and connected)

The Prim's algorithm is chosen because it has a similar logic to DFS, so it is easy for us to discuss and implement them both together.

The mazes generated by Prim's algorithm has many short cul-de-sacs, which is a different aesthetics than mazes created from DFS. This makes the mazes generated by our programe more diverse and interesting.

#### Creating imperfect maze
DFS and Prim's algorithm create perfect mazes.
To generate imperfect mazes, we randonly remove some walls in the perfect mazes.
In this way, the paths are connected in more than one ways and thus creates multiple solutions.

The default setting removes 10% of the walls. This percentage can be changed by passing a float betwenn 0 and 1 to the `make_imperfect()` function in `maze_generator.py`.

The wall removal follows the constraint that the open areas cannot be wider than 2 cells.

### Maze solving algorithm: Breadth-First Search (BFS)
BFS explores the maze level by level (n steps away from the entry cell). The shortest path is found as soon as the exit cell is reached.

- Step 1: Start from he entry cell, mark it as visited, add it to the queue (to be processed), set its parent (previous cell in the path) to be None.
- Step 2: Add unvisited neighbors that are open to the current cell to the queue and set their parents to the current cell.
- Step 3: Remove the current cell from the queue and set the next one as the current cell.
- Step 4: Repeat Step 2 - 3 until the exit cell is found.
- Step 5: Reconstruction the solution from the exit cell using the stored parent information.

BFS is chosen because it has a similar logic to Prim's algorithm, so it is easy for us to implement them together.
BFS is suitable for unweighted graphs, which is the case for our maze.
BFS only need to traverse the graph once to find the shortest path, making it time-efficient. 


## Instruction

### Reusable module

### Format of configuration file


## Project management

### Planning and task divitions
- README (each write own stuff)
- Makefile (lucas)
- Read configuration file and check validity (lucas)
- Generate maze
	- x Grid representation (yanru)
		- x Terminal output for testing
	    - x Fixed 42 pattern and config checking
            - x generate 42 pattern
            - x check grid is big enough
            - x check entry and exit points are not in 42 pattern
	- x Perfect algo1 -> Backtracking (lucas)
	- x Perfect algo2 -> Prim (yanru)
    - x Imperfect maze: randomly remove walls if not form a bigger corridor (yanru)
- x Find shortest path -> Breadth First Search (yanru)
- x Write to output file (yanru)
    - x Write maze to output
    - x Write entry and exit points
    - x Write solution
- Visualization
    - x Display walls (lucas)
    - x Display entry and exit points (lucas)
    - x User interaction (yanru)
        - x Prompt
        - x Regenerate maze
        - x Show/hide solution
        - x Change colors
        - Animation
- Make reuable module

### Reflections
What worked well and what coulde be improved

## Resources
- [Maze generation algorithm: Recursive backtracking](https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking)
- [Maze generation algorithm: Kruskal's algorithm](https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm)
- [Maze generation algorithm: Prim's algorithm](https://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm.html)
- [Solve maze using Breadth First Search (BFS)Algorithm](https://medium.com/@luthfisauqi17_68455/artificial-intelligence-search-problem-solve-maze-using-breadth-first-search-bfs-algorithm-255139c6e1a3)
- [Breadth-First Search in Python](https://www.datacamp.com/tutorial/breadth-first-search-in-python)
- [Python bitwise operators](https://wiki.python.org/moin/BitwiseOperators)
- [mazelib, a python API for creating and solving mazes](https://github.com/john-science/mazelib)
- [List of Unicode Characters of Category “Other Symbol”](https://www.compart.com/en/unicode/category/So)
- [Python curses module documentation](https://docs.python.org/3/library/curses.html)
- [Python curses module tutorial](https://www.youtube.com/playlist?list=PLzMcBGfZo4-n2TONAOImWL4sgZsmyMBc8)
- [256 ANSI color codes](https://hexdocs.pm/color_palette/ansi_color_codes.html)

### Tools used
- **git**: Version control and collaboration
- **flake8**: Code linting and style checking
- **mypy**: Static type checker for Python

AI was used to compare different algorithms and explain them step by step with examples.
